--- origsrc/src/winsup/cygwin/dcrt0.cc	2013-04-07 18:53:00.000000000 -0500
+++ src/src/winsup/cygwin/dcrt0.cc	2013-05-12 01:04:43.545487500 -0500
@@ -1121,7 +1121,7 @@ __main (void)
   sig_dispatch_pending (true);
 }
 
-void __stdcall
+void __reg1
 do_exit (int status)
 {
   syscall_printf ("do_exit (%d), exit_state %d", status, exit_state);
--- origsrc/src/winsup/cygwin/exceptions.cc	2013-04-08 20:01:19.000000000 -0500
+++ src/src/winsup/cygwin/exceptions.cc	2013-05-12 01:12:34.766439800 -0500
@@ -442,7 +442,7 @@ try_to_debug (bool waitloop)
 
 extern "C" void WINAPI RtlUnwind (void *, void *, PEXCEPTION_RECORD, void *);
 static void __reg3 rtl_unwind (exception_list *, PEXCEPTION_RECORD) __attribute__ ((noinline, ));
-void __stdcall
+void __reg3
 rtl_unwind (exception_list *frame, PEXCEPTION_RECORD e)
 {
   __asm__ ("\n\
@@ -739,7 +739,7 @@ _cygtls::interrupt_now (CONTEXT *cx, sig
   return interrupted;
 }
 
-void __stdcall
+void __reg3
 _cygtls::interrupt_setup (siginfo_t& si, void *handler, struct sigaction& siga)
 {
   push ((__stack_t) sigdelayed);
@@ -1154,7 +1154,7 @@ _cygtls::handle_SIGCONT ()
   sig_clear (SIGTTOU);
 }
 
-int __stdcall
+int __reg1
 sigpacket::process ()
 {
   int rc = 1;
--- origsrc/src/winsup/cygwin/fhandler.cc	2013-01-20 22:34:50.000000000 -0600
+++ src/src/winsup/cygwin/fhandler.cc	2013-05-12 01:20:27.624485700 -0500
@@ -216,7 +216,7 @@ fhandler_base::set_flags (int flags, int
 
 /* Cover function to ReadFile to achieve (as much as possible) Posix style
    semantics and use of errno.  */
-void __stdcall
+void __reg3
 fhandler_base::raw_read (void *ptr, size_t& ulen)
 {
 #define bytes_read ulen
@@ -282,7 +282,7 @@ retry:
 
 /* Cover function to WriteFile to provide Posix interface and semantics
    (as much as possible).  */
-ssize_t __stdcall
+ssize_t __reg3
 fhandler_base::raw_write (const void *ptr, size_t len)
 {
   NTSTATUS status;
@@ -723,7 +723,7 @@ done:
    an \n.  If last char is an \r, look ahead one more char, if \n then
    modify \r, if not, remember char.
 */
-void __stdcall
+void __reg3
 fhandler_base::read (void *in_ptr, size_t& len)
 {
   char *ptr = (char *) in_ptr;
@@ -1087,14 +1087,14 @@ fhandler_base::lseek (_off64_t offset, i
   return res;
 }
 
-ssize_t __stdcall
+ssize_t __reg3
 fhandler_base::pread (void *, size_t, _off64_t)
 {
   set_errno (ESPIPE);
   return -1;
 }
 
-ssize_t __stdcall
+ssize_t __reg3
 fhandler_base::pwrite (void *, size_t, _off64_t)
 {
   set_errno (ESPIPE);
@@ -1310,7 +1310,7 @@ fhandler_base::fstat (struct __stat64 *b
   return 0;
 }
 
-int __stdcall
+int __reg2
 fhandler_base::fstatvfs (struct statvfs *sfs)
 {
   /* If we hit this base implementation, it's some device in /dev.
--- origsrc/src/winsup/cygwin/fhandler_console.cc	2013-01-20 22:38:27.000000000 -0600
+++ src/src/winsup/cygwin/fhandler_console.cc	2013-05-12 01:20:51.564855000 -0500
@@ -318,7 +318,7 @@ fhandler_console::mouse_aware (MOUSE_EVE
 		 || dev_state.use_mouse >= 3));
 }
 
-void __stdcall
+void __reg3
 fhandler_console::read (void *pv, size_t& buflen)
 {
   push_process_state process_state (PID_TTYIN);
--- origsrc/src/winsup/cygwin/fhandler_dev.cc	2013-01-20 22:34:51.000000000 -0600
+++ src/src/winsup/cygwin/fhandler_dev.cc	2013-05-12 01:21:10.853958300 -0500
@@ -81,7 +81,7 @@ fhandler_dev::fstat (struct __stat64 *st
   return 0;
 }
 
-int __stdcall
+int __reg2
 fhandler_dev::fstatvfs (struct statvfs *sfs)
 {
   int ret = -1, opened = 0;
--- origsrc/src/winsup/cygwin/fhandler_disk_file.cc	2013-01-20 22:34:51.000000000 -0600
+++ src/src/winsup/cygwin/fhandler_disk_file.cc	2013-05-12 01:26:54.922637900 -0500
@@ -319,7 +319,7 @@ path_conv::ndisk_links (DWORD nNumberOfL
    This returns the content of a struct fattr3 as defined in RFC 1813.
    The content is the NFS equivalent of struct stat. so there's not much
    to do here except for copying. */
-int __stdcall
+int __reg2
 fhandler_base::fstat_by_nfs_ea (struct __stat64 *buf)
 {
   fattr3 *nfs_attr = pc.nfsattr ();
@@ -359,7 +359,7 @@ fhandler_base::fstat_by_nfs_ea (struct _
   return 0;
 }
 
-int __stdcall
+int __reg2
 fhandler_base::fstat_by_handle (struct __stat64 *buf)
 {
   /* Don't use FileAllInformation info class.  It returns a pathname rather
@@ -417,7 +417,7 @@ fhandler_base::fstat_by_handle (struct _
   return fstat_helper (buf, fsi.NumberOfLinks);
 }
 
-int __stdcall
+int __reg2
 fhandler_base::fstat_by_name (struct __stat64 *buf)
 {
   NTSTATUS status;
@@ -461,7 +461,7 @@ fhandler_base::fstat_by_name (struct __s
   return fstat_helper (buf, 1);
 }
 
-int __stdcall
+int __reg2
 fhandler_base::fstat_fs (struct __stat64 *buf)
 {
   int res = -1;
@@ -505,7 +505,7 @@ fhandler_base::fstat_fs (struct __stat64
   return res;
 }
 
-int __stdcall
+int __reg3
 fhandler_base::fstat_helper (struct __stat64 *buf,
 			     DWORD nNumberOfLinks)
 {
@@ -705,7 +705,7 @@ fhandler_disk_file::fstat (struct __stat
   return fstat_fs (buf);
 }
 
-int __stdcall
+int __reg2
 fhandler_disk_file::fstatvfs (struct statvfs *sfs)
 {
   int ret = -1, opened = 0;
@@ -797,7 +797,7 @@ out:
   return ret;
 }
 
-int __stdcall
+int __reg1
 fhandler_disk_file::fchmod (mode_t mode)
 {
   extern int chmod_device (path_conv& pc, mode_t mode);
@@ -905,7 +905,7 @@ out:
   return res;
 }
 
-int __stdcall
+int __reg2
 fhandler_disk_file::fchown (__uid32_t uid, __gid32_t gid)
 {
   int oret = 0;
@@ -973,7 +973,7 @@ fhandler_disk_file::fchown (__uid32_t ui
   return res;
 }
 
-int _stdcall
+int __reg3
 fhandler_disk_file::facl (int cmd, int nentries, __aclent32_t *aclbufp)
 {
   int res = -1;
@@ -1549,7 +1549,7 @@ fhandler_disk_file::prw_open (bool write
   return 0;
 }
 
-ssize_t __stdcall
+ssize_t __reg3
 fhandler_disk_file::pread (void *buf, size_t count, _off64_t offset)
 {
   if ((get_flags () & O_ACCMODE) == O_WRONLY)
@@ -1561,7 +1561,7 @@ fhandler_disk_file::pread (void *buf, si
   /* In binary mode, we can use an atomic NtReadFile call. */
   if (rbinary ())
     {
-      extern int __stdcall is_at_eof (HANDLE h);
+      extern int __reg2 is_at_eof (HANDLE h);
       NTSTATUS status;
       IO_STATUS_BLOCK io;
       LARGE_INTEGER off = { QuadPart:offset };
@@ -1619,7 +1619,7 @@ non_atomic:
   return res;
 }
 
-ssize_t __stdcall
+ssize_t __reg3
 fhandler_disk_file::pwrite (void *buf, size_t count, _off64_t offset)
 {
   if ((get_flags () & O_ACCMODE) == O_RDONLY)
@@ -1935,7 +1935,7 @@ free_dir:
   return res;
 }
 
-__ino64_t __stdcall
+__ino64_t __reg2
 readdir_get_ino (const char *path, bool dot_dot)
 {
   char *fname;
@@ -2431,7 +2431,7 @@ fhandler_cygdrive::fstat (struct __stat6
   return 0;
 }
 
-int __stdcall
+int __reg2
 fhandler_cygdrive::fstatvfs (struct statvfs *sfs)
 {
   /* Virtual file system.  Just return an empty buffer with a few values
--- origsrc/src/winsup/cygwin/fhandler_dsp.cc	2012-06-17 15:50:24.000000000 -0500
+++ src/src/winsup/cygwin/fhandler_dsp.cc	2013-05-12 01:27:13.218684400 -0500
@@ -1093,7 +1093,7 @@ fhandler_dev_dsp::write (const void *ptr
   return len - len_s + written;
 }
 
-void __stdcall
+void __reg3
 fhandler_dev_dsp::read (void *ptr, size_t& len)
 {
   debug_printf ("ptr=%08x len=%d", ptr, len);
--- origsrc/src/winsup/cygwin/fhandler_fifo.cc	2013-01-20 22:34:51.000000000 -0600
+++ src/src/winsup/cygwin/fhandler_fifo.cc	2013-05-12 01:27:34.250887300 -0500
@@ -274,7 +274,7 @@ fhandler_fifo::wait (HANDLE h)
    }
 }
 
-void __stdcall
+void __reg3
 fhandler_fifo::raw_read (void *in_ptr, size_t& len)
 {
   size_t orig_len = len;
--- origsrc/src/winsup/cygwin/fhandler_floppy.cc	2013-03-31 07:37:45.000000000 -0500
+++ src/src/winsup/cygwin/fhandler_floppy.cc	2013-05-12 01:27:52.642939300 -0500
@@ -426,7 +426,7 @@ fhandler_dev_floppy::get_current_positio
   return off.QuadPart;
 }
 
-void __stdcall
+void __reg3
 fhandler_dev_floppy::raw_read (void *ptr, size_t& ulen)
 {
   DWORD bytes_read = 0;
@@ -558,7 +558,7 @@ err:
   ulen = (size_t) -1;
 }
 
-int __stdcall
+int __reg3
 fhandler_dev_floppy::raw_write (const void *ptr, size_t len)
 {
   DWORD bytes_written = 0;
--- origsrc/src/winsup/cygwin/fhandler_mailslot.cc	2013-01-20 22:34:51.000000000 -0600
+++ src/src/winsup/cygwin/fhandler_mailslot.cc	2013-05-12 01:28:08.668855900 -0500
@@ -146,7 +146,7 @@ fhandler_mailslot::open (int flags, mode
   return res;
 }
 
-ssize_t __stdcall
+ssize_t __reg3
 fhandler_mailslot::raw_write (const void *ptr, size_t len)
 {
   /* Check for 425/426 byte weirdness */
--- origsrc/src/winsup/cygwin/fhandler_mem.cc	2013-01-20 22:34:51.000000000 -0600
+++ src/src/winsup/cygwin/fhandler_mem.cc	2013-05-12 01:28:36.781463900 -0500
@@ -159,7 +159,7 @@ fhandler_dev_mem::write (const void *ptr
   return ulen;
 }
 
-void __stdcall
+void __reg3
 fhandler_dev_mem::read (void *ptr, size_t& ulen)
 {
   if (!ulen || pos >= mem_size)
--- origsrc/src/winsup/cygwin/fhandler_process.cc	2013-01-20 22:34:51.000000000 -0600
+++ src/src/winsup/cygwin/fhandler_process.cc	2013-05-12 01:31:53.364707800 -0500
@@ -1203,7 +1203,7 @@ format_process_mountstuff (void *data, c
 	 each cygdrive entry if it's a remote drive.  If so, ignore it. */
       if (iteration >= mtab->nmounts && u_hdl)
 	{
-	  WCHAR drive[3] = { mnt->mnt_fsname[0], L':', L'\0' };
+	  WCHAR drive[3] = { (WCHAR) mnt->mnt_fsname[0], L':', L'\0' };
 	  disk_type dt = get_disk_type (drive);
 
 	  if (dt == DT_SHARE_SMB || dt == DT_SHARE_NFS)
--- origsrc/src/winsup/cygwin/fhandler_procsys.cc	2013-01-20 22:34:51.000000000 -0600
+++ src/src/winsup/cygwin/fhandler_procsys.cc	2013-05-12 01:33:27.382085300 -0500
@@ -391,7 +391,7 @@ fhandler_procsys::closedir (DIR *dir)
   return fhandler_virtual::closedir (dir);
 }
 
-void __stdcall
+void __reg3
 fhandler_procsys::read (void *ptr, size_t& len)
 {
   NTSTATUS status;
--- origsrc/src/winsup/cygwin/fhandler_random.cc	2011-11-13 19:29:48.000000000 -0600
+++ src/src/winsup/cygwin/fhandler_random.cc	2013-05-12 01:33:59.705934100 -0500
@@ -114,7 +114,7 @@ fhandler_dev_random::pseudo_read (void *
   return len;
 }
 
-void __stdcall
+void __reg3
 fhandler_dev_random::read (void *ptr, size_t& len)
 {
   if (!len)
--- origsrc/src/winsup/cygwin/fhandler_serial.cc	2013-01-20 22:38:27.000000000 -0600
+++ src/src/winsup/cygwin/fhandler_serial.cc	2013-05-12 01:34:25.370402000 -0500
@@ -41,7 +41,7 @@ fhandler_serial::overlapped_setup ()
   overlapped_armed = 0;
 }
 
-void __stdcall
+void __reg3
 fhandler_serial::raw_read (void *ptr, size_t& ulen)
 {
   int tot;
@@ -167,7 +167,7 @@ out:
 
 /* Cover function to WriteFile to provide Posix interface and semantics
    (as much as possible).  */
-ssize_t __stdcall
+ssize_t __reg3
 fhandler_serial::raw_write (const void *ptr, size_t len)
 {
   DWORD bytes_written;
--- origsrc/src/winsup/cygwin/fhandler_socket.cc	2013-04-08 12:34:34.000000000 -0500
+++ src/src/winsup/cygwin/fhandler_socket.cc	2013-05-12 01:42:03.307594500 -0500
@@ -844,7 +844,7 @@ fhandler_socket::fstat (struct __stat64
   return res;
 }
 
-int __stdcall
+int __reg2
 fhandler_socket::fstatvfs (struct statvfs *sfs)
 {
   if (get_device () == FH_UNIX)
@@ -1355,7 +1355,7 @@ fhandler_socket::getpeername (struct soc
   return res;
 }
 
-void __stdcall
+void __reg3
 fhandler_socket::read (void *in_ptr, size_t& len)
 {
   WSABUF wsabuf = { len, (char *) in_ptr };
@@ -1375,7 +1375,7 @@ fhandler_socket::readv (const struct iov
       wsaptr->len = (--iovptr)->iov_len;
       wsaptr->buf = (char *) iovptr->iov_base;
     }
-  WSAMSG wsamsg = { NULL, 0, wsabuf, iovcnt, { 0,  NULL}, 0 };
+  WSAMSG wsamsg = { NULL, 0, wsabuf, (DWORD) iovcnt, { 0,  NULL}, 0 };
   return recv_internal (&wsamsg, false);
 }
 
@@ -1566,7 +1566,7 @@ fhandler_socket::recvfrom (void *ptr, si
   WSAMSG wsamsg = { from, from && fromlen ? *fromlen : 0,
 		    &wsabuf, 1,
 		    { 0, NULL},
-		    flags };
+		    (DWORD) flags };
   ssize_t ret = recv_internal (&wsamsg, false);
   if (fromlen)
     *fromlen = wsamsg.namelen;
@@ -1599,9 +1599,9 @@ fhandler_socket::recvmsg (struct msghdr
       wsaptr->buf = (char *) iovptr->iov_base;
     }
   WSAMSG wsamsg = { (struct sockaddr *) msg->msg_name, msg->msg_namelen,
-		    wsabuf, msg->msg_iovlen,
-		    { msg->msg_controllen, (char *) msg->msg_control },
-		    flags };
+		    wsabuf, (DWORD) msg->msg_iovlen,
+		    { (DWORD) msg->msg_controllen, (char *) msg->msg_control },
+		    (DWORD) flags };
   ssize_t ret = recv_internal (&wsamsg, use_recvmsg);
   if (ret >= 0)
     {
@@ -1633,7 +1633,7 @@ fhandler_socket::writev (const struct io
       wsaptr->len = iovptr->iov_len;
       (wsaptr++)->buf = (char *) (iovptr++)->iov_base;
     }
-  WSAMSG wsamsg = { NULL, 0, wsabuf, iovcnt, { 0, NULL}, 0 };
+  WSAMSG wsamsg = { NULL, 0, wsabuf, (DWORD) iovcnt, { 0, NULL}, 0 };
   return send_internal (&wsamsg, 0);
 }
 
@@ -1763,14 +1763,14 @@ fhandler_socket::sendmsg (const struct m
       (wsaptr++)->buf = (char *) (iovptr++)->iov_base;
     }
   WSAMSG wsamsg = { msg->msg_name ? (struct sockaddr *) &sst : NULL, len,
-		    wsabuf, msg->msg_iovlen,
+		    wsabuf, (DWORD) msg->msg_iovlen,
 		    /* Disappointing but true:  Even if WSASendMsg is
 		       supported, it's only supported for datagram and
 		       raw sockets. */
 		    { !wincap.has_sendmsg ()
 		      || get_socket_type () == SOCK_STREAM
 		      || get_addr_family () == AF_LOCAL
-		      ? 0 : msg->msg_controllen, (char *) msg->msg_control },
+		      ? 0 : (DWORD) msg->msg_controllen, (char *) msg->msg_control },
 		    0 };
   return send_internal (&wsamsg, flags);
 }
--- origsrc/src/winsup/cygwin/fhandler_tape.cc	2013-01-20 22:34:51.000000000 -0600
+++ src/src/winsup/cygwin/fhandler_tape.cc	2013-05-12 01:45:07.897152500 -0500
@@ -722,7 +722,7 @@ mtinfo_drive::set_compression (HANDLE mt
   TAPE_SET_DRIVE_PARAMETERS sdp =
     {
       dp ()->ECC,
-      count ? TRUE : FALSE,
+      (BOOLEAN) (count ? TRUE : FALSE),
       dp ()->DataPadding,
       dp ()->ReportSetmarks,
       dp ()->EOTWarningZoneSize
@@ -738,7 +738,7 @@ mtinfo_drive::set_compression (HANDLE mt
 }
 
 int
-mtinfo_drive::set_blocksize (HANDLE mt, long count)
+mtinfo_drive::set_blocksize (HANDLE mt, DWORD count)
 {
   TAPE_SET_MEDIA_PARAMETERS smp = {count};
   TAPE_FUNC (SetTapeParameters (mt, SET_TAPE_MEDIA_INFORMATION, &smp));
@@ -1240,7 +1240,7 @@ fhandler_dev_tape::close ()
   return ret ? -1 : cret;
 }
 
-void __stdcall
+void __reg3
 fhandler_dev_tape::raw_read (void *ptr, size_t &ulen)
 {
   char *buf = (char *) ptr;
@@ -1341,7 +1341,7 @@ fhandler_dev_tape::raw_read (void *ptr,
   unlock ();
 }
 
-ssize_t __stdcall
+ssize_t __reg3
 fhandler_dev_tape::raw_write (const void *ptr, size_t len)
 {
   if (!_lock (true))
--- origsrc/src/winsup/cygwin/fhandler_tty.cc	2013-01-30 23:26:46.000000000 -0600
+++ src/src/winsup/cygwin/fhandler_tty.cc	2013-05-12 01:51:44.544839400 -0500
@@ -689,7 +689,7 @@ fhandler_pty_slave::write (const void *p
   return towrite;
 }
 
-void __stdcall
+void __reg3
 fhandler_pty_slave::read (void *ptr, size_t& len)
 {
   int totalread = 0;
@@ -1155,7 +1155,7 @@ fhandler_pty_slave::fch_close_handles ()
   close_maybe (inuse);
 }
 
-int __stdcall
+int __reg1
 fhandler_pty_slave::fchmod (mode_t mode)
 {
   int ret = -1;
@@ -1181,7 +1181,7 @@ errout:
   return ret;
 }
 
-int __stdcall
+int __reg2
 fhandler_pty_slave::fchown (__uid32_t uid, __gid32_t gid)
 {
   int ret = -1;
@@ -1360,7 +1360,7 @@ fhandler_pty_master::write (const void *
   return i;
 }
 
-void __stdcall
+void __reg3
 fhandler_pty_master::read (void *ptr, size_t& len)
 {
   bg_check_types bg = bg_check (SIGTTIN);
--- origsrc/src/winsup/cygwin/fhandler_virtual.cc	2013-01-20 22:38:27.000000000 -0600
+++ src/src/winsup/cygwin/fhandler_virtual.cc	2013-05-12 01:52:21.952979000 -0500
@@ -181,7 +181,7 @@ fhandler_virtual::close ()
   return 0;
 }
 
-void __stdcall
+void __reg3
 fhandler_virtual::read (void *ptr, size_t& len)
 {
   if (len == 0)
@@ -266,7 +266,7 @@ fhandler_virtual::facl (int cmd, int nen
   return res;
 }
 
-int __stdcall
+int __reg2
 fhandler_virtual::fstatvfs (struct statvfs *sfs)
 {
   /* Virtual file system.  Just return an empty buffer with a few values
--- origsrc/src/winsup/cygwin/fhandler_windows.cc	2013-01-20 22:38:27.000000000 -0600
+++ src/src/winsup/cygwin/fhandler_windows.cc	2013-05-12 01:52:57.946037700 -0500
@@ -84,7 +84,7 @@ fhandler_windows::write (const void *buf
   return sizeof (MSG);
 }
 
-void __stdcall
+void __reg3
 fhandler_windows::read (void *buf, size_t& len)
 {
   MSG *ptr = (MSG *) buf;
--- origsrc/src/winsup/cygwin/fhandler_zero.cc	2013-01-20 22:38:27.000000000 -0600
+++ src/src/winsup/cygwin/fhandler_zero.cc	2013-05-12 01:53:26.553674000 -0500
@@ -41,7 +41,7 @@ fhandler_dev_zero::write (const void *,
   return len;
 }
 
-void __stdcall
+void __reg3
 fhandler_dev_zero::read (void *ptr, size_t& len)
 {
   memset (ptr, 0, len);
--- origsrc/src/winsup/cygwin/kernel32.cc	2013-01-20 22:38:27.000000000 -0600
+++ src/src/winsup/cygwin/kernel32.cc	2013-05-12 01:57:06.586259100 -0500
@@ -310,7 +310,7 @@ CreateFileMappingW (HANDLE hFile, LPSECU
   ULONG attribs = flProtect & (SEC_COMMIT | SEC_IMAGE | SEC_NOCACHE
 			       | SEC_RESERVE);
   LARGE_INTEGER size = {{ LowPart  : dwMaximumSizeLow,
-			  HighPart : dwMaximumSizeHigh }};
+			  HighPart : (LONG) dwMaximumSizeHigh }};
   PLARGE_INTEGER psize = size.QuadPart ? &size : NULL;
 
   if (prot & (PAGE_READWRITE | PAGE_WRITECOPY
--- origsrc/src/winsup/cygwin/miscfuncs.cc	2013-01-23 08:06:06.000000000 -0600
+++ src/src/winsup/cygwin/miscfuncs.cc	2013-05-12 02:07:35.534232900 -0500
@@ -32,7 +32,7 @@ details. */
 
 long tls_ix = -1;
 
-const char case_folded_lower[] NO_COPY = {
+const unsigned char case_folded_lower[] NO_COPY = {
    0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,
   16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,
   32, '!', '"', '#', '$', '%', '&',  39, '(', ')', '*', '+', ',', '-', '.', '/',
@@ -51,7 +51,7 @@ const char case_folded_lower[] NO_COPY =
  240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255
 };
 
-const char case_folded_upper[] NO_COPY = {
+const unsigned char case_folded_upper[] NO_COPY = {
    0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,
   16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,
   32, '!', '"', '#', '$', '%', '&',  39, '(', ')', '*', '+', ',', '-', '.', '/',
@@ -177,7 +177,7 @@ cygwin_strupr (char *string)
   return string;
 }
 
-int __stdcall
+int __reg2
 check_invalid_virtual_addr (const void *s, unsigned sz)
 {
   MEMORY_BASIC_INFORMATION mbuf;
--- origsrc/src/winsup/cygwin/mtinfo.h	2008-07-15 06:42:45.000000000 -0500
+++ src/src/winsup/cygwin/mtinfo.h	2013-05-12 01:45:27.163254400 -0500
@@ -98,7 +98,7 @@ class mtinfo_drive
   int erase (HANDLE mt, int mode);
   int prepare (HANDLE mt, int action, bool is_auto = false);
   int set_compression (HANDLE mt, long count);
-  int set_blocksize (HANDLE mt, long count);
+  int set_blocksize (HANDLE mt, DWORD count);
   int get_status (HANDLE mt, struct mtget *get);
   int set_options (HANDLE mt, long options);
   int async_wait (HANDLE mt, DWORD *bytes_written);
--- origsrc/src/winsup/cygwin/nlsfuncs.cc	2013-01-20 22:38:27.000000000 -0600
+++ src/src/winsup/cygwin/nlsfuncs.cc	2013-05-12 02:13:09.172315900 -0500
@@ -1196,8 +1196,8 @@ strcoll (const char *s1, const char *s2)
 extern "C" int
 __collate_range_cmp (int c1, int c2)
 {
-  char s1[2] = { c1, '\0' };
-  char s2[2] = { c2, '\0' };
+  char s1[2] = { (char) c1, '\0' };
+  char s2[2] = { (char) c2, '\0' };
   return strcoll (s1, s2);
 }
 
--- origsrc/src/winsup/cygwin/ntea.cc	2013-01-20 22:38:27.000000000 -0600
+++ src/src/winsup/cygwin/ntea.cc	2013-05-12 02:13:38.125971900 -0500
@@ -30,7 +30,7 @@ details. */
 #define NEXT_FEA(p) ((PFILE_FULL_EA_INFORMATION) (p->NextEntryOffset \
 		     ? (char *) p + p->NextEntryOffset : NULL))
 
-ssize_t __stdcall
+ssize_t __reg3
 read_ea (HANDLE hdl, path_conv &pc, const char *name, char *value, size_t size)
 {
   OBJECT_ATTRIBUTES attr;
@@ -216,7 +216,7 @@ out:
   return ret;
 }
 
-int __stdcall
+int __reg3
 write_ea (HANDLE hdl, path_conv &pc, const char *name, const char *value,
 	  size_t size, int flags)
 {
--- origsrc/src/winsup/cygwin/path.cc	2013-04-12 03:30:47.000000000 -0500
+++ src/src/winsup/cygwin/path.cc	2013-05-12 02:15:45.073232900 -0500
@@ -343,7 +343,7 @@ path_conv::add_ext_from_sym (symlink_inf
 
 static void __reg2 mkrelpath (char *dst, bool caseinsensitive);
 
-static void __stdcall
+static void __reg2
 mkrelpath (char *path, bool caseinsensitive)
 {
   tmp_pathbuf tp;
@@ -1363,7 +1363,7 @@ normalize_win32_path (const char *src, c
 /* nofinalslash: Remove trailing / and \ from SRC (except for the
    first one).  It is ok for src == dst.  */
 
-void __stdcall
+void __reg2
 nofinalslash (const char *src, char *dst)
 {
   int len = strlen (src);
@@ -2841,7 +2841,7 @@ readlink (const char *path, char *buf, s
    done during the opendir call and the hash or the filename within
    the directory.  FIXME: Not bullet-proof. */
 /* Cygwin internal */
-__ino64_t __stdcall
+__ino64_t __reg2
 hash_path_name (__ino64_t hash, PUNICODE_STRING name)
 {
   if (name->Length == 0)
@@ -2855,7 +2855,7 @@ hash_path_name (__ino64_t hash, PUNICODE
   return hash;
 }
 
-__ino64_t __stdcall
+__ino64_t __reg2
 hash_path_name (__ino64_t hash, PCWSTR name)
 {
   UNICODE_STRING uname;
@@ -2863,7 +2863,7 @@ hash_path_name (__ino64_t hash, PCWSTR n
   return hash_path_name (hash, &uname);
 }
 
-__ino64_t __stdcall
+__ino64_t __reg2
 hash_path_name (__ino64_t hash, const char *name)
 {
   UNICODE_STRING uname;
@@ -3385,7 +3385,6 @@ cygwin_conv_path_list (cygwin_conv_path_
   int ret;
   char *winp = NULL;
   void *orig_to = NULL;
-  size_t orig_size = (size_t) -1;
   tmp_pathbuf tp;
 
   switch (what & CCP_CONVTYPE_MASK)
@@ -3403,7 +3402,6 @@ cygwin_conv_path_list (cygwin_conv_path_
 	       * sizeof (WCHAR);
       what = (what & ~CCP_CONVTYPE_MASK) | CCP_POSIX_TO_WIN_A;
       orig_to = to;
-      orig_size = size;
       to = (void *) tp.w_get ();
       size = 65536;
       break;
--- origsrc/src/winsup/cygwin/pinfo.cc	2013-03-29 11:19:11.000000000 -0500
+++ src/src/winsup/cygwin/pinfo.cc	2013-05-12 02:16:16.971057400 -0500
@@ -491,7 +491,7 @@ _pinfo::set_ctty (fhandler_termios *fh,
 
 /* Test to determine if a process really exists and is processing signals.
  */
-bool __stdcall
+bool __reg1
 _pinfo::exists ()
 {
   return this && process_state && !(process_state & (PID_EXITED | PID_REAPED | PID_EXECED));
--- origsrc/src/winsup/cygwin/pipe.cc	2013-01-20 22:34:52.000000000 -0600
+++ src/src/winsup/cygwin/pipe.cc	2013-05-12 02:16:35.952143000 -0500
@@ -392,7 +392,7 @@ fhandler_pipe::ioctl (unsigned int cmd,
   return 0;
 }
 
-int __stdcall
+int __reg2
 fhandler_pipe::fstatvfs (struct statvfs *sfs)
 {
   set_errno (EBADF);
--- origsrc/src/winsup/cygwin/regex/engine.c	2010-02-11 15:19:19.000000000 -0600
+++ src/src/winsup/cygwin/regex/engine.c	2013-05-12 02:19:51.464325700 -0500
@@ -160,7 +160,7 @@ matcher(struct re_guts *g,
 	int i;
 	struct match mv;
 	struct match *m = &mv;
-	const char *dp;
+	const char *dp = NULL;
 	const sopno gf = g->firststate+1;	/* +1 for OEND */
 	const sopno gl = g->laststate;
 	const char *start;
@@ -391,7 +391,7 @@ dissect(struct match *m,
 	const char *ssp;	/* start of string matched by subsubRE */
 	const char *sep;	/* end of string matched by subsubRE */
 	const char *oldssp;	/* previous ssp */
-	const char *dp;
+	const char *dp __attribute__ ((unused));
 
 	AT("diss", start, stop, startst, stopst);
 	sp = start;
--- origsrc/src/winsup/cygwin/regex/regcomp.c	2012-06-11 17:15:27.000000000 -0500
+++ src/src/winsup/cygwin/regex/regcomp.c	2013-05-12 02:18:03.342141400 -0500
@@ -1477,8 +1477,8 @@ static void
 findmust(struct parse *p, struct re_guts *g)
 {
 	sop *scan;
-	sop *start;
-	sop *newstart;
+	sop *start = NULL;
+	sop *newstart = NULL;
 	sopno newlen;
 	sop s;
 	char *cp;
--- origsrc/src/winsup/cygwin/sched.cc	2013-01-20 22:38:28.000000000 -0600
+++ src/src/winsup/cygwin/sched.cc	2013-05-12 02:24:48.696326400 -0500
@@ -315,7 +315,6 @@ sched_setparam (pid_t pid, const struct
   pid_t localpid;
   int winpri;
   DWORD Class;
-  int ThreadPriority;
   HANDLE process;
 
   if (!param || pid < 0)
@@ -342,70 +341,6 @@ sched_setparam (pid_t pid, const struct
   else
     Class = NORMAL_PRIORITY_CLASS;
 
-  switch (Class)
-    {
-    case IDLE_PRIORITY_CLASS:
-      switch (winpri)
-	{
-	case 1:
-	  ThreadPriority = THREAD_PRIORITY_IDLE;
-	  break;
-	case 2:
-	  ThreadPriority = THREAD_PRIORITY_LOWEST;
-	  break;
-	case 3:
-	  ThreadPriority = THREAD_PRIORITY_BELOW_NORMAL;
-	  break;
-	case 4:
-	  ThreadPriority = THREAD_PRIORITY_NORMAL;
-	  break;
-	case 5:
-	  ThreadPriority = THREAD_PRIORITY_ABOVE_NORMAL;
-	  break;
-	case 6:
-	  ThreadPriority = THREAD_PRIORITY_HIGHEST;
-	  break;
-	}
-      break;
-    case NORMAL_PRIORITY_CLASS:
-      switch (winpri)
-	{
-	case 7:
-	  ThreadPriority = THREAD_PRIORITY_LOWEST;
-	  break;
-	case 8:
-	  ThreadPriority = THREAD_PRIORITY_BELOW_NORMAL;
-	  break;
-	case 9:
-	  ThreadPriority = THREAD_PRIORITY_NORMAL;
-	  break;
-	case 10:
-	  ThreadPriority = THREAD_PRIORITY_ABOVE_NORMAL;
-	  break;
-	case 11:
-	  ThreadPriority = THREAD_PRIORITY_HIGHEST;
-	  break;
-	}
-      break;
-    case HIGH_PRIORITY_CLASS:
-      switch (winpri)
-	{
-	case 12:
-	  ThreadPriority = THREAD_PRIORITY_BELOW_NORMAL;
-	  break;
-	case 13:
-	  ThreadPriority = THREAD_PRIORITY_NORMAL;
-	  break;
-	case 14:
-	  ThreadPriority = THREAD_PRIORITY_ABOVE_NORMAL;
-	  break;
-	case 15:
-	  ThreadPriority = THREAD_PRIORITY_HIGHEST;
-	  break;
-	}
-      break;
-    }
-
   localpid = pid ? pid : getpid ();
 
   pinfo p (localpid);
--- origsrc/src/winsup/cygwin/sec_acl.cc	2013-01-20 22:38:28.000000000 -0600
+++ src/src/winsup/cygwin/sec_acl.cc	2013-05-12 02:26:22.590696800 -0500
@@ -495,12 +495,10 @@ aclcheck32 (__aclent32_t *aclbufp, int n
   bool has_group_obj = false;
   bool has_other_obj = false;
   bool has_class_obj = false;
-  bool has_ug_objs = false;
   bool has_def_user_obj = false;
   bool has_def_group_obj = false;
   bool has_def_other_obj = false;
   bool has_def_class_obj = false;
-  bool has_def_ug_objs = false;
   int pos2;
 
   for (int pos = 0; pos < nentries; ++pos)
@@ -551,7 +549,6 @@ aclcheck32 (__aclent32_t *aclbufp, int n
 	      *which = pos2;
 	    return DUPLICATE_ERROR;
 	  }
-	has_ug_objs = true;
 	break;
       case DEF_USER_OBJ:
 	if (has_def_user_obj)
@@ -598,7 +595,6 @@ aclcheck32 (__aclent32_t *aclbufp, int n
 	      *which = pos2;
 	    return DUPLICATE_ERROR;
 	  }
-	has_def_ug_objs = true;
 	break;
       default:
 	return ENTRY_ERROR;
@@ -606,11 +602,6 @@ aclcheck32 (__aclent32_t *aclbufp, int n
   if (!has_user_obj
       || !has_group_obj
       || !has_other_obj
-#if 0
-      /* These checks are not ok yet since CLASS_OBJ isn't fully implemented. */
-      || (has_ug_objs && !has_class_obj)
-      || (has_def_ug_objs && !has_def_class_obj)
-#endif
      )
     {
       if (which)
--- origsrc/src/winsup/cygwin/sec_helper.cc	2013-01-20 22:38:28.000000000 -0600
+++ src/src/winsup/cygwin/sec_helper.cc	2013-05-12 02:26:51.927374800 -0500
@@ -551,7 +551,7 @@ sec_acl (PACL acl, bool original, bool a
   return true;
 }
 
-PSECURITY_ATTRIBUTES __stdcall
+PSECURITY_ATTRIBUTES __reg3
 __sec_user (PVOID sa_buf, PSID sid1, PSID sid2, DWORD access2, BOOL inherit)
 {
   PSECURITY_ATTRIBUTES psa = (PSECURITY_ATTRIBUTES) sa_buf;
--- origsrc/src/winsup/cygwin/shared.cc	2013-01-20 22:38:28.000000000 -0600
+++ src/src/winsup/cygwin/shared.cc	2013-05-12 02:31:31.695376600 -0500
@@ -115,8 +115,8 @@ shared_name (WCHAR *ret_buf, const WCHAR
   return ret_buf;
 }
 
-#define page_const (65535)
-#define pround(n) (((size_t) (n) + page_const) & ~page_const)
+#define page_const ((ptrdiff_t) 65535)
+#define pround(n) ((ptrdiff_t)(((n) + page_const) & ~page_const))
 
 /* The order in offsets is so that the constant blocks shared_info
    and user_info are right below the cygwin DLL, then the pinfo block
--- origsrc/src/winsup/cygwin/signal.cc	2013-01-30 23:26:46.000000000 -0600
+++ src/src/winsup/cygwin/signal.cc	2013-05-12 02:32:53.604061500 -0500
@@ -187,7 +187,7 @@ sigprocmask (int how, const sigset_t *se
   return res;
 }
 
-int __stdcall
+int __reg3
 handle_sigprocmask (int how, const sigset_t *set, sigset_t *oldset, sigset_t& opmask)
 {
   /* check that how is in right range */
@@ -227,7 +227,7 @@ handle_sigprocmask (int how, const sigse
   return 0;
 }
 
-int __stdcall
+int __reg2
 _pinfo::kill (siginfo_t& si)
 {
   int res;
--- origsrc/src/winsup/cygwin/spawn.cc	2013-03-31 07:35:44.000000000 -0500
+++ src/src/winsup/cygwin/spawn.cc	2013-05-12 02:34:53.062894200 -0500
@@ -99,7 +99,7 @@ perhaps_suffix (const char *prog, path_c
    of name is placed in buf and returned.  Otherwise the contents of buf
    is undefined and NULL is returned.  */
 
-const char * __stdcall
+const char * __reg3
 find_exec (const char *name, path_conv& buf, const char *mywinenv,
 	   unsigned opt, const char **known_suffix)
 {
@@ -784,7 +784,6 @@ loop:
   /* Name the handle similarly to proc_subproc. */
   ProtectHandle1 (pi.hProcess, childhProc);
 
-  pid_t pid;
   if (mode == _P_OVERLAY)
     {
       myself->dwProcessId = pi.dwProcessId;
@@ -792,7 +791,6 @@ loop:
       myself.hProcess = hExeced = pi.hProcess;
       real_path.get_wide_win32_path (myself->progname); // FIXME: race?
       sigproc_printf ("new process name %W", myself->progname);
-      pid = myself->pid;
       if (!iscygwin ())
 	close_all_files ();
     }
@@ -832,7 +830,6 @@ loop:
 	  res = -1;
 	  goto out;
 	}
-      pid = child->pid;
     }
 
   /* Start the child running */
--- origsrc/src/winsup/cygwin/strfuncs.cc	2013-01-20 22:38:28.000000000 -0600
+++ src/src/winsup/cygwin/strfuncs.cc	2013-05-12 02:35:56.779538600 -0500
@@ -410,7 +410,7 @@ __big5_mbtowc (struct _reent *r, wchar_t
        to buffer size, it's a bug in Cygwin and the buffer in the calling
        function should be raised.
 */
-size_t __stdcall
+size_t __reg3
 sys_cp_wcstombs (wctomb_p f_wctomb, const char *charset, char *dst, size_t len,
 		 const wchar_t *src, size_t nwc)
 {
@@ -496,7 +496,7 @@ sys_cp_wcstombs (wctomb_p f_wctomb, cons
   return n;
 }
 
-size_t __stdcall
+size_t __reg3
 sys_wcstombs (char *dst, size_t len, const wchar_t * src, size_t nwc)
 {
   return sys_cp_wcstombs (cygheap->locale.wctomb, cygheap->locale.charset,
@@ -513,7 +513,7 @@ sys_wcstombs (char *dst, size_t len, con
    Note that this code is shared by cygserver (which requires it via
    __small_vsprintf) and so when built there plain calloc is the
    only choice.  */
-size_t __stdcall
+size_t __reg3
 sys_wcstombs_alloc (char **dst_p, int type, const wchar_t *src, size_t nwc)
 {
   size_t ret;
@@ -539,7 +539,7 @@ sys_wcstombs_alloc (char **dst_p, int ty
    conversion.  This is so that fhandler_console can switch to an alternate
    charset, which is the charset returned by GetConsoleCP ().  Most of the
    time this is used for box and line drawing characters. */
-size_t __stdcall
+size_t __reg3
 sys_cp_mbstowcs (mbtowc_p f_mbtowc, const char *charset, wchar_t *dst,
 		 size_t dlen, const char *src, size_t nms)
 {
@@ -648,7 +648,7 @@ sys_cp_mbstowcs (mbtowc_p f_mbtowc, cons
   return count;
 }
 
-size_t __stdcall
+size_t __reg3
 sys_mbstowcs (wchar_t * dst, size_t dlen, const char *src, size_t nms)
 {
   return sys_cp_mbstowcs (cygheap->locale.mbtowc, cygheap->locale.charset,
@@ -656,7 +656,7 @@ sys_mbstowcs (wchar_t * dst, size_t dlen
 }
 
 /* Same as sys_wcstombs_alloc, just backwards. */
-size_t __stdcall
+size_t __reg3
 sys_mbstowcs_alloc (wchar_t **dst_p, int type, const char *src, size_t nms)
 {
   size_t ret;
--- origsrc/src/winsup/cygwin/syscalls.cc	2013-01-20 22:38:28.000000000 -0600
+++ src/src/winsup/cygwin/syscalls.cc	2013-05-12 02:36:30.194449800 -0500
@@ -1825,7 +1825,7 @@ sync ()
 }
 
 /* Cygwin internal */
-int __stdcall
+int __reg2
 stat_worker (path_conv &pc, struct __stat64 *buf)
 {
   int res = -1;
--- origsrc/src/winsup/cygwin/syslog.cc	2013-01-20 22:38:28.000000000 -0600
+++ src/src/winsup/cygwin/syslog.cc	2013-05-12 02:38:16.902553100 -0500
@@ -249,7 +249,7 @@ connect_syslogd ()
 }
 
 static int
-try_connect_syslogd (int priority, const char *msg, int len)
+try_connect_syslogd (int priority, const char *msg, size_t len)
 {
   ssize_t ret = -1;
 
--- origsrc/src/winsup/cygwin/thread.cc	2013-04-07 18:53:00.000000000 -0500
+++ src/src/winsup/cygwin/thread.cc	2013-05-12 02:40:10.728063600 -0500
@@ -38,7 +38,11 @@ extern "C" void __fp_lock_all ();
 extern "C" void __fp_unlock_all ();
 extern "C" int valid_sched_parameters(const struct sched_param *);
 extern "C" int sched_set_thread_priority(HANDLE thread, int priority);
+#if __GNUC__ == 4 && __GNUC_MINOR__ >= 7
+static verifyable_object_state
+#else
 static inline verifyable_object_state
+#endif
   verifyable_object_isvalid (void const * objectptr, thread_magic_t magic,
 			     void *static_ptr1 = NULL,
 			     void *static_ptr2 = NULL,
@@ -117,7 +121,11 @@ __cygwin_lock_unlock (_LOCK_T *lock)
   paranoid_printf ("threadcount %d.  unlocked", MT_INTERFACE->threadcount);
 }
 
+#if __GNUC__ == 4 && __GNUC_MINOR__ >= 7
+static verifyable_object_state
+#else
 static inline verifyable_object_state
+#endif
 verifyable_object_isvalid (void const *objectptr, thread_magic_t magic, void *static_ptr1,
 			   void *static_ptr2, void *static_ptr3)
 {
--- origsrc/src/winsup/cygwin/tty.cc	2011-12-30 14:22:27.000000000 -0600
+++ src/src/winsup/cygwin/tty.cc	2013-05-12 02:41:00.644918700 -0500
@@ -85,7 +85,7 @@ tty::init_session ()
     cygheap->fdtab.get_debugger_info ();
 }
 
-int __stdcall
+int __reg2
 tty_list::attach (int n)
 {
   int res;
--- origsrc/src/winsup/cygwin/window.cc	2013-01-20 22:38:29.000000000 -0600
+++ src/src/winsup/cygwin/window.cc	2013-05-12 02:42:50.943227400 -0500
@@ -26,7 +26,7 @@ wininfo NO_COPY winmsg;
 
 muto NO_COPY wininfo::_lock;
 
-int __stdcall
+int __reg3
 wininfo::process (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
 {
 #ifndef NOSTRACE
@@ -57,7 +57,7 @@ process_window_events (HWND hwnd, UINT u
 }
 
 /* Handle windows events.  Inherits ownership of the wininfo lock */
-DWORD WINAPI
+DWORD __reg1 WINAPI
 wininfo::winthread ()
 {
   MSG msg;
--- origsrc/src/winsup/cygwin/winsup.h	2013-01-20 22:34:52.000000000 -0600
+++ src/src/winsup/cygwin/winsup.h	2013-05-12 02:08:16.264562500 -0500
@@ -83,9 +83,9 @@ int fcntl64 (int fd, int cmd, ...);
 #define __reg2 __stdcall __attribute__ ((regparm (2)))
 #define __reg3 __stdcall __attribute__ ((regparm (3)))
 
-extern const char case_folded_lower[];
+extern const unsigned char case_folded_lower[];
 #define cyg_tolower(c) (case_folded_lower[(unsigned char)(c)])
-extern const char case_folded_upper[];
+extern const unsigned char case_folded_upper[];
 #define cyg_toupper(c) (case_folded_upper[(unsigned char)(c)])
 
 #ifndef MALLOC_DEBUG
